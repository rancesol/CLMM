

##|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
##\\\\\\\\| FIT HALO MASS TO SHEAR PROFILE: 3. ACCOUNTING FOR THE REDSHIFT DISTRIBUTION OF SOURCE GALAXIES |/////////
##A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\VAVAVAVAV////////////////////////////////////////////////////A
##AA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\VAVAVAV////////////////////////////////////////////////////AA
##AAA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\VAVAV////////////////////////////////////////////////////AAA
##AAAA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\VAV////////////////////////////////////////////////////AAAA
##AAAAA\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\V////////////////////////////////////////////////////AAAAA


## THIS DEMONSTRATES HOW TO USE clmm TO ESTIMATE A WL HALO MASS FROM OBSERVATIONS OF A GALAXY CLUSTER WHEN SOURCE
## GALAXIES FOLLOW A GIVEN DISTRIBUTION (CHANGE ET AL. (2013)).
## IT USES SEVERAL FUNCTIONALITIES OF THE SUPPORT mock_data MODULE TO PRODUCE MOCK DATASETS.
## OUTLINE:
##      @ SET THINGS UP WITH IMPORTS
##      @ GENERATE 2 DATASETS:
##          - AN IDEAL DATASET WITH SOURCE GALAXIES FOLLOWING CHANG ET AL. (2013) RESHIFT DISTRIBUTION
##          - A NOISY DATASET WHERE PHOTOZ ERRORS AND SHAPE NOISE ARE ALSO INCLUDED
##      @ COMPUTING THE BINNED REDUCED TANGENTIAL SHEAR PROFILES USING LOGARITHMIC BINNING
##      @ SETTING UP THE 'SINGLE SOURCE PLANE' MODEL AND A MODEL ACCOUNTING FOR THE REDSHIFT DISTRIBUTION.
##      @ WE ALSO ADD TWO MODELS USING THE METHODS FROM APPLEGATE ET AL. (2014) AND SCHRABBACK ET AL. (2018)
##      @ PERFORM A SIMPLE FIT USING scipy.optimize.curve_fit AND VISUALIZE THE RESULTS.




##WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
##|||||||||||||||||||||||||||||||||||||||||||||||||||||| SETUP ||||||||||||||||||||||||||||||||||||||||||||||||||||||
##VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

import clmm
import matplotlib.pyplot as plt
import numpy as np
from astropy import units
plt.rcParams['font.family'] = ['gothambook', 'gotham', 'gotham-book', 'serif']

import clmm.dataops as da
import clmm.galaxycluster as gc
import clmm.theory as theory
from clmm import Cosmology




##WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
##||||||||||||||||||||||||||||||||||||||||||||||||| MAKING MOCK DATA ||||||||||||||||||||||||||||||||||||||||||||||||
##VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

from clmm.support import mock_data as mock

np.random.seed(11)

## DEFINE THE COSMOLOGY FOR THE MOCK DATA
H0 = 70.
Omega_b0 = 0.045
Omega_dm0 = 0.27 - Omega_b0
Omega_k0 = 0.
cosmo = Cosmology(H0=H0, Omega_dm0=Omega_dm0, Omega_b0=Omega_b0, Omega_k0=Omega_k0)


## NOW SET SOME PARAMETERS FOR A MOCK GALAXY CLUSTER
cl_mass = 1.e15
logm    = np.log10(cl_mass)
cl_conc = 4.
cl_ra   = 20.
cl_dec  = 90.
cl_z    = 0.4
ngals   = int(1e4)


## NOW MAKE THE mock_data (THE GALAXIES  HAVE A MINIMUM REDSHIFT DEFINED AS cl_z + 0.1)
ideal_data = mock.generate_galaxy_catalog(cl_mass, cl_z, cl_conc, cosmo, 'chang13', zsrc_min=cl_z+0.1, ngals=ngals, cluster_ra=cl_ra, cluster_dec=cl_dec)
noisy_data = mock.generate_galaxy_catalog(cl_mass, cl_z, cl_conc, cosmo, 'chang13', zsrc_min=cl_z+0.1, ngals=ngals, cluster_ra=cl_ra, cluster_dec=cl_dec, shapenoise=0.05, photoz_sigma_unscaled=0.05)


## CONVERT THE GALAXY CATALOGS TO clmm.GalaxyCluster OBJECTS
cl_id = 'CL_ideal'
gc_object = clmm.GalaxyCluster(cl_id, cl_ra, cl_dec, cl_z, ideal_data)
gc_object.save('ideal_GC.pkl')

cl_id = 'CL_noisy'
gc_object = clmm.GalaxyCluster(cl_id, cl_ra, cl_dec, cl_z, noisy_data)
gc_object.save('noisy_GC.pkl')


## NOW READ THE OBJECTS BACK IN FROM THE FILE FOR ANALYSIS
cl_ideal = clmm.GalaxyCluster.load('ideal_GC.pkl')
cl_noisy = clmm.GalaxyCluster.load('noisy_GC.pkl')




##WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
##|||||||||||||||| REDSHIFT OF GALAXIES GENERATED BY MOCK DATA WITH CHANG ET AL. (2013) DISTRIBUTION ||||||||||||||||
##VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

fsize=15
plt.figure(figsize=(7,5))
plt.hist(cl_ideal.galcat['z'], density=True, bins=50)
plt.axvline(x=cl_z, color='orange', label='cluster redshift')
plt.xlabel(r'$z_{src}$', fontsize=fsize)
plt.ylabel(r'$N(z)$', fontsize=fsize)
plt.xlim(0,5)
plt.legend()

plt.show()



##WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
##||||||||||||||||||||||||||||||||||||||||||||||||| COMPUTING SHEAR |||||||||||||||||||||||||||||||||||||||||||||||||
##VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

## OPTIONAL ARGUMENT: geometry='flat'; DEFAULT IS: geometry='curve'
cl_ideal.compute_tangential_and_cross_components()
cl_noisy.compute_tangential_and_cross_components()



##WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
##|||||||||||||||||||||||||||||||||||||||||||| RADIALLY BINNING THE DATA ||||||||||||||||||||||||||||||||||||||||||||
##VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

bin_edges = da.make_bins(0.2, 4., 15, method='evenlog10width')

cl_ideal.make_radial_profile('Mpc', bins=bin_edges, cosmo=cosmo, gal_ids_in_bins=True)
cl_noisy.make_radial_profile('Mpc', bins=bin_edges, cosmo=cosmo, gal_ids_in_bins=True)



##WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
##|||||||||||||||||||||||||||||||||||| CREATE THE REDUCED TANGENTIAL SHEAR MODELS |||||||||||||||||||||||||||||||||||
##VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

## CONSIDER THREE OPTIONS:
##      @ OPTION 1: THE NAIVE AND WRONG APPROACH
##          - THE REDUCED TANGENTIAL SHEAR IN A GIVEN RADIAL BIN j IS GIVEN BY g_t(theta_j, <z_s>)
##      @ OPTION 2:
##          - THE REDUCED TANGENTIAL SHEAR IN A GIVEN RADIAL BIN ACCOUNTS PROPERLY FOR THE REDSHIFT DISTRIBUTION IN 
##            THE BIN AS <g_t(theta_j,z_s)> != g_t(theta_j,<z_s>). FORMALLY, THE REDUCED TANGENTIAL SHEAR THAT
##            CORRESPONDS TO A CONTINUOUS DISTRIBUTION OF SOURCE GALAXY REDSHIFT N(z) CAN BE EXPRESSED AS:
##                  g_t(theta) = <g_t(theta,z_s)>_{z_cl} = integer^infty_{z_cl} dz_s N(z_s)g_t(theta,z_s)
##            IF THE INDIVIDUAL REDSHIFTS OF THE BACKGROUND GALAXIES ARE KNOWN WE CAN DIRECTLY BUILD A MODEL BASED ON
##            DATA:
##                  g_t(theta_j) = (1/N(theta_j)) SUM_{i=1}^{N(theta)} g_t(theta_j, z_i)
##            WHERE N(theta_j) IS THE NUMBER OF GALAXIES IN BIN j.
##      @ OPTION 3:
##          - CONSIDER TWO MODELS THAT USE THE STATISTICS OF ANGULAR DIAMETER DISTANCE RATIO (beta_s)



## OPTION 1
def model_reduced_tangential_shear_singlez(r, logm, z_src) :
    m = 10.**logm
    gt_model = clmm.compute_reduced_tangential_shear(r, m, cl_conc, cl_z, z_src, cosmo, delta_mdef=200, halo_profile_model='nfw')
    return gt_model

## OPTION 2
def model_reduced_tangential_shear_zdistrib(radius, logm, data, catalog, profile) :
    m = 10.**logm
    gt_model = []
    for i in range(len(radius)) :
        r = profile['radius'][i]
        galist = profile['gal_id'][i]
        z_list = catalog.galcat['z'][galist]
        shear = clmm.compute_reduced_tangential_shear(r, m, cl_conc, cl_z, z_list, cosmo, delta_mdef=200, halo_profile_model='nfw')
        gt_model.append(np.mean(shear))
    return gt_model

## OPTION 3: FIRST THE METHOD FROM APPLEGATE ET AL. (2014) AND THEN THE METHOD FROM SCHRABBACK ET AL. (2018)
z_inf = 1e3

def model_reduced_tangential_shear_applegate14(logm, catalog, profile) :
    z_values = catalog.galcat['z']
    gt_model = clmm.compute_reduced_tangential_shear(
            r_proj = profile['radius'],     ## RADIAL COMPONENT OF THE PROFILE
            mdelta = 10.**logm,             ## MASS OF THE CLUSTER IN M_sun
            cdelta = cl_conc,               ## CONCENTRATION OF THE CLUSTER
            z_cluster=cl_z,                 ## REDSHIFT OF THE CLUSTER
            z_source=z_inf,                 ## REDHSHIFT VALUE CAN BE ARBITRARY BECAUSE IT'S NOT USED HERE
            cosmo=cosmo,
            delta_mdef = 200,
            halo_profile_model = 'nfw',
            z_src_model = 'applegate14',
            z_distrib_func = clmm.utils._chang_z_distrib, )     ## THE REDSHIFT DISTRIBUTION; CHANG ET AL. (2013)
    return gt_model

def model_reduced_tangential_shear_schrabback18(logm, catalog, profile) :
    z_values = catalog.galcat['z']
    gt_model = clmm.compute_reduced_tangential_shear(
            r_proj = profile['radius'],     ## RADIAL COMPONENT OF THE PROFILE
            mdelta = 10.**logm,             ## MASS OF THE CLUSTER IN M_sun
            cdelta = cl_conc,               ## CONCENTRATION OF THE CLUSTER
            z_cluster=cl_z,                 ## REDSHIFT OF THE CLUSTER
            z_source=z_inf,                 ## REDHSHIFT VALUE CAN BE ARBITRARY BECAUSE IT'S NOT USED HERE
            cosmo=cosmo,
            delta_mdef = 200,
            halo_profile_model = 'nfw',
            z_src_model = 'schrabback18',
            z_distrib_func = clmm.utils._chang_z_distrib, )     ## THE REDSHIFT DISTRIBUTION; CHANG ET AL. (2013)
    return gt_model




## NOW LETS VISUALISE THESE MODELS BEFORE WE START FITTING THEM
logm = np.log10(cl_mass)
r = cl_ideal.profile['radius']

gt_model_ideal_singlez      = model_reduced_tangential_shear_singlez(r, logm, cl_ideal.profile['z'])
gt_model_ideal_zdistrib     = model_reduced_tangential_shear_zdistrib(r, logm, ideal_data, cl_ideal, cl_ideal.profile)
gt_model_ideal_applegate14  = model_reduced_tangential_shear_applegate14(logm, cl_ideal, cl_ideal.profile)
gt_model_ideal_schrabback18 = model_reduced_tangential_shear_schrabback18(logm, cl_ideal, cl_ideal.profile)

## NOISY DATA CAN HAVE SOME SOURCE REDSHIFTS THAT ARE LOWER THAN THE CLUSTER REDSHIFT.
gt_model_noisy_singlez      = model_reduced_tangential_shear_singlez(r, logm, cl_noisy.profile['z'])
gt_model_noisy_zdistrib     = model_reduced_tangential_shear_zdistrib(r, logm, noisy_data, cl_noisy, cl_noisy.profile)
gt_model_noisy_applegate14  = model_reduced_tangential_shear_applegate14(logm, cl_noisy, cl_noisy.profile)
gt_model_noisy_schrabback18 = model_reduced_tangential_shear_schrabback18(logm, cl_noisy, cl_noisy.profile)

## THE BLUE SOLID CURVE AND RED/GREEN DOTTED CURVES ARE EXPECTED TO BE CLOSE.
fsize=15
plt.figure(figsize=(20,8))

plt.subplot(1,2,1)
plt.title('ideal data', fontsize=fsize)
plt.errorbar(r, cl_ideal.profile['gt'], cl_ideal.profile['gt_err'], c='k', linestyle='none', marker='o', label=r'ideal data, $M_{input}$ = %.2e $M_{\odot}$' % cl_mass)
plt.loglog(r, gt_model_ideal_singlez, '-y', label=r'model w/o zdistrib, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_model_ideal_zdistrib, '-b', label=r'model w/ zdistrib, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_model_ideal_applegate14, ':r', label=r'model applegate14, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_model_ideal_schrabback18, ':g', label=r'model schrabback18, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))

plt.xlabel(r'$r$ [Mpc]', fontsize=fsize)
plt.ylabel(r'$g_t$', fontsize=fsize)
plt.xlim(min(cl_ideal.profile['radius']), max(cl_ideal.profile['radius']))
plt.legend(fontsize=fsize)

plt.subplot(1,2,2)
plt.title('noisy data', fontsize=fsize)
plt.errorbar(r, cl_noisy.profile['gt'], cl_noisy.profile['gt_err'], c='k', linestyle='none', marker='o', label=r'noisy data, $M_{input}$ = %.2e $M_{\odot}$' % cl_mass)
plt.loglog(r, gt_model_noisy_singlez, '-y', label=r'model w/o zdistrib, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_model_noisy_zdistrib, '-b', label=r'model w/ zdistrib, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_model_noisy_applegate14, ':r', label=r'model applegate14, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_model_noisy_schrabback18, ':g', label=r'model schrabback18, $M_{{input}} = {:.2e} M_{{\odot}}$'.format(cl_mass))

plt.xlabel(r'$r$ [Mpc]', fontsize=fsize)
plt.ylabel(r'$g_t$', fontsize=fsize)
plt.xlim(min(cl_noisy.profile['radius']), max(cl_noisy.profile['radius']))
plt.legend(fontsize=fsize)

plt.show()

## CLEARLY THE NAIVE MODEL USING THE BINNED REDSHIFTS DOES NOT GIVE THE RIGHT DESCRIPTION OF THE IDEAL DATA.




##WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
##||||||||||||||||||||||||||||||||||||||||||||||||||| MASS FITTING ||||||||||||||||||||||||||||||||||||||||||||||||||
##VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

## COMPARE ESTIMATED MASS FOR NOISY AND IDEAL DATA.
## THE CHOICE OF FITTING log10(M) INSTEAD OF M LOWERS THE RANGE OF PREDEFINED FITTING BOUNDS FROM SEVERAL ORDERS OF
## MAGNITUDE FOR THE MASS TO UNITY.
## FROM THE ASSOCIATED ERROR Delta(log10(M)) WE CALCULATE THE ERROR TO MASS AS DeltaM = M_fit ln(10)*Delta(log10(M)).

from clmm.support.sampler import fitters

## IDEAL
popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_singlez(r, logm, cl_ideal.profile['z']),
        cl_ideal.profile['radius'],
        cl_ideal.profile['gt'],
        cl_ideal.profile['gt_err'],
        bounds=[10.,16.])

m_est_ideal_singlez = 10.**popt[0]
m_est_err_ideal_singlez = m_est_ideal_singlez * np.sqrt(pcov[0][0]) * np.log(10)


popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_zdistrib(r, logm, ideal_data, cl_ideal, cl_ideal.profile),
        cl_ideal.profile['radius'],
        cl_ideal.profile['gt'],
        cl_ideal.profile['gt_err'],
        bounds=[10.,16.])

m_est_ideal_zdistrib = 10.**popt[0]
m_est_err_ideal_zdistrib = m_est_ideal_zdistrib * np.sqrt(pcov[0][0]) * np.log(10)


popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_applegate14(logm, cl_ideal, cl_ideal.profile),
        cl_ideal.profile['radius'],
        cl_ideal.profile['gt'],
        cl_ideal.profile['gt_err'],
        bounds=[10.,16.])

m_est_ideal_applegate14 = 10.**popt[0]
m_est_err_ideal_applegate14 = m_est_ideal_applegate14 * np.sqrt(pcov[0][0]) * np.log(10)


popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_schrabback18(logm, cl_ideal, cl_ideal.profile),
        cl_ideal.profile['radius'],
        cl_ideal.profile['gt'],
        cl_ideal.profile['gt_err'],
        bounds=[10.,16.])

m_est_ideal_schrabback18 = 10.**popt[0]
m_est_err_ideal_schrabback18 = m_est_ideal_schrabback18 * np.sqrt(pcov[0][0]) * np.log(10)



## NOISY
popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_singlez(r, logm, cl_noisy.profile['z']),
        cl_noisy.profile['radius'],
        cl_noisy.profile['gt'],
        cl_noisy.profile['gt_err'],
        bounds=[10.,16.])

m_est_noisy_singlez = 10.**popt[0]
m_est_err_noisy_singlez = m_est_noisy_singlez * np.sqrt(pcov[0][0]) * np.log(10)


popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_zdistrib(r, logm, noisy_data, cl_noisy, cl_noisy.profile),
        cl_noisy.profile['radius'],
        cl_noisy.profile['gt'],
        cl_noisy.profile['gt_err'],
        bounds=[10.,16.])

m_est_noisy_zdistrib = 10.**popt[0]
m_est_err_noisy_zdistrib = m_est_noisy_zdistrib * np.sqrt(pcov[0][0]) * np.log(10)


popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_applegate14(logm, cl_noisy, cl_noisy.profile),
        cl_noisy.profile['radius'],
        cl_noisy.profile['gt'],
        cl_noisy.profile['gt_err'],
        bounds=[10.,16.])

m_est_noisy_applegate14 = 10.**popt[0]
m_est_err_noisy_applegate14 = m_est_noisy_applegate14 * np.sqrt(pcov[0][0]) * np.log(10)


popt, pcov = fitters['curve_fit'](lambda r, logm:model_reduced_tangential_shear_schrabback18(logm, cl_noisy, cl_noisy.profile),
        cl_noisy.profile['radius'],
        cl_noisy.profile['gt'],
        cl_noisy.profile['gt_err'],
        bounds=[10.,16.])

m_est_noisy_schrabback18 = 10.**popt[0]
m_est_err_noisy_schrabback18 = m_est_noisy_schrabback18 * np.sqrt(pcov[0][0]) * np.log(10)


print(f'input mass = {cl_mass:.2e}$M_{{\odot}}$\n')
print("Without accounting for the redshift distribution in the model\n")
print(f'Best fit mass for ideal data = {m_est_ideal_singlez:.2e} +/- {m_est_err_ideal_singlez:.2e} Msun')
print(f'Best fit mass for noisy data = {m_est_noisy_singlez:.2e} +/- {m_est_err_noisy_singlez:.2e} Msun\n')

print("Accounting for the redshift distribution in the model\n")
print(f'Best fit mass for ideal data = {m_est_ideal_zdistrib:.2e} +/- {m_est_err_ideal_zdistrib:.2e} Msun')
print(f'Best fit mass for noisy data = {m_est_noisy_zdistrib:.2e} +/- {m_est_err_noisy_zdistrib:.2e} Msun\n')

print("Using applegate14 (Applegate et al. 2014)\n")
print(f'Best fit mass for ideal data = {m_est_ideal_applegate14:.2e} +/- {m_est_err_ideal_applegate14:.2e} Msun')
print(f'Best fit mass for noisy data = {m_est_noisy_applegate14:.2e} +/- {m_est_err_noisy_applegate14:.2e} Msun\n')

print("Using schrabback18 (Schrabback et al. 2018)\n")
print(f'Best fit mass for ideal data = {m_est_ideal_schrabback18:.2e} +/- {m_est_err_ideal_schrabback18:.2e} Msun')
print(f'Best fit mass for noisy data = {m_est_noisy_schrabback18:.2e} +/- {m_est_err_noisy_schrabback18:.2e} Msun\n')


gt_est_ideal_singlez      = model_reduced_tangential_shear_singlez(r, np.log10(m_est_ideal_singlez), cl_ideal.profile['z'])
gt_est_ideal_zdistrib     = model_reduced_tangential_shear_zdistrib(r, np.log10(m_est_ideal_zdistrib), ideal_data, cl_ideal, cl_ideal.profile)
gt_est_ideal_applegate14  = model_reduced_tangential_shear_applegate14(np.log10(m_est_ideal_applegate14), cl_ideal, cl_ideal.profile)
gt_est_ideal_schrabback18 = model_reduced_tangential_shear_schrabback18(np.log10(m_est_ideal_schrabback18), cl_ideal, cl_ideal.profile)

gt_est_noisy_singlez      = model_reduced_tangential_shear_singlez(r, np.log10(m_est_noisy_singlez), cl_noisy.profile['z'])
gt_est_noisy_zdistrib     = model_reduced_tangential_shear_zdistrib(r, np.log10(m_est_noisy_zdistrib), noisy_data, cl_noisy, cl_noisy.profile)
gt_est_noisy_applegate14  = model_reduced_tangential_shear_applegate14(np.log10(m_est_noisy_applegate14), cl_noisy, cl_noisy.profile)
gt_est_noisy_schrabback18 = model_reduced_tangential_shear_schrabback18(np.log10(m_est_noisy_schrabback18), cl_noisy, cl_noisy.profile)


plt.figure(figsize=(20, 10))

plt.subplot(1,2,1)
plt.title(r'tangential shear $g_t$ (ideal data)', fontsize=fsize)
plt.errorbar(r, cl_ideal.profile['gt'], cl_ideal.profile['gt_err'], c='k', linestyle='none', marker='o', label=r'ideal data, $M_{{input}} = {:.2e}M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_est_ideal_singlez, '-y', label=r'model w/o zdistrib, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_ideal_singlez, m_est_err_ideal_singlez))
plt.loglog(r, gt_est_ideal_zdistrib, '-b', label=r'model w/ zdistrib, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_ideal_zdistrib, m_est_err_ideal_zdistrib))
plt.loglog(r, gt_est_ideal_applegate14, ':r', label=r'model applegate14, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_ideal_applegate14, m_est_err_ideal_applegate14))
plt.loglog(r, gt_est_ideal_schrabback18, ':g', label=r'model schrabback18, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_ideal_schrabback18, m_est_err_ideal_schrabback18))

plt.xlabel(r'$r$ [Mpc]', fontsize=fsize)
plt.ylabel(r'$g_t$', fontsize=fsize)
plt.xlim(min(cl_ideal.profile['radius']), max(cl_ideal.profile['radius']))
plt.legend(fontsize=fsize)

plt.subplot(1,2,2)
plt.title(r'tangential shear $g_t$ (noisy data)', fontsize=fsize)
plt.errorbar(r, cl_noisy.profile['gt'], cl_noisy.profile['gt_err'], c='k', linestyle='none', marker='o', label=r'noisy data, $M_{{input}} = {:.2e}M_{{\odot}}$'.format(cl_mass))
plt.loglog(r, gt_est_noisy_singlez, '-y', label=r'model w/o zdistrib, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_noisy_singlez, m_est_err_noisy_singlez))
plt.loglog(r, gt_est_noisy_zdistrib, '-b', label=r'model w/ zdistrib, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_noisy_zdistrib, m_est_err_noisy_zdistrib))
plt.loglog(r, gt_est_noisy_applegate14, ':r', label=r'model applegate14, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_noisy_applegate14, m_est_err_noisy_applegate14))
plt.loglog(r, gt_est_noisy_schrabback18, ':g', label=r'model schrabback18, $M_{{fit}} = {:.2e} \pm {:.2e} M_{{\odot}}$'.format(m_est_noisy_schrabback18, m_est_err_noisy_schrabback18))

plt.xlabel(r'$r$ [Mpc]', fontsize=fsize)
plt.ylabel(r'$g_t$', fontsize=fsize)
plt.xlim(min(cl_noisy.profile['radius']), max(cl_noisy.profile['radius']))
plt.legend(fontsize=fsize)

plt.show()


